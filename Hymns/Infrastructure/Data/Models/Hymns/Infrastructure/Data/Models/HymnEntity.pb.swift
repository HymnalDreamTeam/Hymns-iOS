// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Hymns/Infrastructure/Data/Models/HymnEntity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum HymnType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case classic // = 0
  case newTune // = 1
  case newSong // = 2
  case children // = 3
  case howardHigashi // = 4
  case dutch // = 5
  case german // = 6
  case chinese // = 7
  case chineseSimplified // = 8
  case chineseSupplemental // = 9
  case chineseSupplementalSimplified // = 10
  case cebuano // = 11
  case tagalog // = 12
  case french // = 13
  case spanish // = 14
  case korean // = 15
  case japanese // = 16
  case indonesian // = 17
  case farsi // = 18
  case russian // = 19
  case portuguese // = 20
  case beFilled // = 21
  case liederbuch // = 22
  case hinos // = 23
  case hebrew // = 24
  case slovak // = 25
  case estonian // = 26
  case arabic // = 27
  case blueSongbook // = 28
  case liedboek // = 29
  case songbaseOther // = 30
  case UNRECOGNIZED(Int)

  init() {
    self = .classic
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .classic
    case 1: self = .newTune
    case 2: self = .newSong
    case 3: self = .children
    case 4: self = .howardHigashi
    case 5: self = .dutch
    case 6: self = .german
    case 7: self = .chinese
    case 8: self = .chineseSimplified
    case 9: self = .chineseSupplemental
    case 10: self = .chineseSupplementalSimplified
    case 11: self = .cebuano
    case 12: self = .tagalog
    case 13: self = .french
    case 14: self = .spanish
    case 15: self = .korean
    case 16: self = .japanese
    case 17: self = .indonesian
    case 18: self = .farsi
    case 19: self = .russian
    case 20: self = .portuguese
    case 21: self = .beFilled
    case 22: self = .liederbuch
    case 23: self = .hinos
    case 24: self = .hebrew
    case 25: self = .slovak
    case 26: self = .estonian
    case 27: self = .arabic
    case 28: self = .blueSongbook
    case 29: self = .liedboek
    case 30: self = .songbaseOther
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .classic: return 0
    case .newTune: return 1
    case .newSong: return 2
    case .children: return 3
    case .howardHigashi: return 4
    case .dutch: return 5
    case .german: return 6
    case .chinese: return 7
    case .chineseSimplified: return 8
    case .chineseSupplemental: return 9
    case .chineseSupplementalSimplified: return 10
    case .cebuano: return 11
    case .tagalog: return 12
    case .french: return 13
    case .spanish: return 14
    case .korean: return 15
    case .japanese: return 16
    case .indonesian: return 17
    case .farsi: return 18
    case .russian: return 19
    case .portuguese: return 20
    case .beFilled: return 21
    case .liederbuch: return 22
    case .hinos: return 23
    case .hebrew: return 24
    case .slovak: return 25
    case .estonian: return 26
    case .arabic: return 27
    case .blueSongbook: return 28
    case .liedboek: return 29
    case .songbaseOther: return 30
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [HymnType] = [
    .classic,
    .newTune,
    .newSong,
    .children,
    .howardHigashi,
    .dutch,
    .german,
    .chinese,
    .chineseSimplified,
    .chineseSupplemental,
    .chineseSupplementalSimplified,
    .cebuano,
    .tagalog,
    .french,
    .spanish,
    .korean,
    .japanese,
    .indonesian,
    .farsi,
    .russian,
    .portuguese,
    .beFilled,
    .liederbuch,
    .hinos,
    .hebrew,
    .slovak,
    .estonian,
    .arabic,
    .blueSongbook,
    .liedboek,
    .songbaseOther,
  ]

}

enum VerseType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case verse // = 0
  case chorus // = 1
  case other // = 2
  case copyright // = 3
  case note // = 4
  case doNotDisplay // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .verse
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .verse
    case 1: self = .chorus
    case 2: self = .other
    case 3: self = .copyright
    case 4: self = .note
    case 5: self = .doNotDisplay
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .verse: return 0
    case .chorus: return 1
    case .other: return 2
    case .copyright: return 3
    case .note: return 4
    case .doNotDisplay: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VerseType] = [
    .verse,
    .chorus,
    .other,
    .copyright,
    .note,
    .doNotDisplay,
  ]

}

enum Language: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case english // = 0
  case dutch // = 1
  case german // = 2
  case chineseTraditional // = 3
  case chineseSimplified // = 4
  case cebuano // = 5
  case tagalog // = 6
  case french // = 7
  case spanish // = 8
  case korean // = 9
  case japanese // = 10
  case farsi // = 11
  case russian // = 12
  case portuguese // = 13
  case hebrew // = 14
  case slovak // = 15
  case estonian // = 16
  case arabic // = 17
  case indonesian // = 18
  case UNRECOGNIZED(Int)

  init() {
    self = .english
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .english
    case 1: self = .dutch
    case 2: self = .german
    case 3: self = .chineseTraditional
    case 4: self = .chineseSimplified
    case 5: self = .cebuano
    case 6: self = .tagalog
    case 7: self = .french
    case 8: self = .spanish
    case 9: self = .korean
    case 10: self = .japanese
    case 11: self = .farsi
    case 12: self = .russian
    case 13: self = .portuguese
    case 14: self = .hebrew
    case 15: self = .slovak
    case 16: self = .estonian
    case 17: self = .arabic
    case 18: self = .indonesian
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .english: return 0
    case .dutch: return 1
    case .german: return 2
    case .chineseTraditional: return 3
    case .chineseSimplified: return 4
    case .cebuano: return 5
    case .tagalog: return 6
    case .french: return 7
    case .spanish: return 8
    case .korean: return 9
    case .japanese: return 10
    case .farsi: return 11
    case .russian: return 12
    case .portuguese: return 13
    case .hebrew: return 14
    case .slovak: return 15
    case .estonian: return 16
    case .arabic: return 17
    case .indonesian: return 18
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Language] = [
    .english,
    .dutch,
    .german,
    .chineseTraditional,
    .chineseSimplified,
    .cebuano,
    .tagalog,
    .french,
    .spanish,
    .korean,
    .japanese,
    .farsi,
    .russian,
    .portuguese,
    .hebrew,
    .slovak,
    .estonian,
    .arabic,
    .indonesian,
  ]

}

struct HymnEntity: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var references: [HymnIdentifierEntity] {
    get {return _storage._references}
    set {_uniqueStorage()._references = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var lyrics: LyricsEntity {
    get {return _storage._lyrics ?? LyricsEntity()}
    set {_uniqueStorage()._lyrics = newValue}
  }
  /// Returns true if `lyrics` has been explicitly set.
  var hasLyrics: Bool {return _storage._lyrics != nil}
  /// Clears the value of `lyrics`. Subsequent reads from it will return its default value.
  mutating func clearLyrics() {_uniqueStorage()._lyrics = nil}

  var category: [String] {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  var subcategory: [String] {
    get {return _storage._subcategory}
    set {_uniqueStorage()._subcategory = newValue}
  }

  var author: [String] {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  var composer: [String] {
    get {return _storage._composer}
    set {_uniqueStorage()._composer = newValue}
  }

  var key: [String] {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  var time: [String] {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  var meter: [String] {
    get {return _storage._meter}
    set {_uniqueStorage()._meter = newValue}
  }

  var scriptures: [String] {
    get {return _storage._scriptures}
    set {_uniqueStorage()._scriptures = newValue}
  }

  var hymnCode: [String] {
    get {return _storage._hymnCode}
    set {_uniqueStorage()._hymnCode = newValue}
  }

  var music: MusicEntity {
    get {return _storage._music ?? MusicEntity()}
    set {_uniqueStorage()._music = newValue}
  }
  /// Returns true if `music` has been explicitly set.
  var hasMusic: Bool {return _storage._music != nil}
  /// Clears the value of `music`. Subsequent reads from it will return its default value.
  mutating func clearMusic() {_uniqueStorage()._music = nil}

  var svgSheet: SvgSheetEntity {
    get {return _storage._svgSheet ?? SvgSheetEntity()}
    set {_uniqueStorage()._svgSheet = newValue}
  }
  /// Returns true if `svgSheet` has been explicitly set.
  var hasSvgSheet: Bool {return _storage._svgSheet != nil}
  /// Clears the value of `svgSheet`. Subsequent reads from it will return its default value.
  mutating func clearSvgSheet() {_uniqueStorage()._svgSheet = nil}

  var pdfSheet: PdfSheetEntity {
    get {return _storage._pdfSheet ?? PdfSheetEntity()}
    set {_uniqueStorage()._pdfSheet = newValue}
  }
  /// Returns true if `pdfSheet` has been explicitly set.
  var hasPdfSheet: Bool {return _storage._pdfSheet != nil}
  /// Clears the value of `pdfSheet`. Subsequent reads from it will return its default value.
  mutating func clearPdfSheet() {_uniqueStorage()._pdfSheet = nil}

  var languages: LanguagesEntity {
    get {return _storage._languages ?? LanguagesEntity()}
    set {_uniqueStorage()._languages = newValue}
  }
  /// Returns true if `languages` has been explicitly set.
  var hasLanguages: Bool {return _storage._languages != nil}
  /// Clears the value of `languages`. Subsequent reads from it will return its default value.
  mutating func clearLanguages() {_uniqueStorage()._languages = nil}

  var relevants: RelevantsEntity {
    get {return _storage._relevants ?? RelevantsEntity()}
    set {_uniqueStorage()._relevants = newValue}
  }
  /// Returns true if `relevants` has been explicitly set.
  var hasRelevants: Bool {return _storage._relevants != nil}
  /// Clears the value of `relevants`. Subsequent reads from it will return its default value.
  mutating func clearRelevants() {_uniqueStorage()._relevants = nil}

  var inlineChords: InlineChordsEntity {
    get {return _storage._inlineChords ?? InlineChordsEntity()}
    set {_uniqueStorage()._inlineChords = newValue}
  }
  /// Returns true if `inlineChords` has been explicitly set.
  var hasInlineChords: Bool {return _storage._inlineChords != nil}
  /// Clears the value of `inlineChords`. Subsequent reads from it will return its default value.
  mutating func clearInlineChords() {_uniqueStorage()._inlineChords = nil}

  var provenance: [String] {
    get {return _storage._provenance}
    set {_uniqueStorage()._provenance = newValue}
  }

  /// column with just the text, used for de-duping and recommendations.
  var flattenedLyrics: String {
    get {return _storage._flattenedLyrics}
    set {_uniqueStorage()._flattenedLyrics = newValue}
  }

  var language: Language {
    get {return _storage._language}
    set {_uniqueStorage()._language = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct HymnIdentifierEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hymnType: HymnType = .classic

  var hymnNumber: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LyricsEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var verses: [VerseEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VerseEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var verseType: VerseType = .verse

  var lines: [LineEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LineEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lineContent: String = String()

  var transliteration: String {
    get {return _transliteration ?? String()}
    set {_transliteration = newValue}
  }
  /// Returns true if `transliteration` has been explicitly set.
  var hasTransliteration: Bool {return self._transliteration != nil}
  /// Clears the value of `transliteration`. Subsequent reads from it will return its default value.
  mutating func clearTransliteration() {self._transliteration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transliteration: String? = nil
}

struct InlineChordsEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chordLines: [ChordLineEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ChordLineEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chordWords: [ChordWordEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ChordWordEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var word: String = String()

  var chords: String {
    get {return _chords ?? String()}
    set {_chords = newValue}
  }
  /// Returns true if `chords` has been explicitly set.
  var hasChords: Bool {return self._chords != nil}
  /// Clears the value of `chords`. Subsequent reads from it will return its default value.
  mutating func clearChords() {self._chords = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chords: String? = nil
}

struct MusicEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var music: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SvgSheetEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var svgSheet: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PdfSheetEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pdfSheet: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LanguagesEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var languages: [HymnIdentifierEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RelevantsEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var relevants: [HymnIdentifierEntity] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HymnType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLASSIC"),
    1: .same(proto: "NEW_TUNE"),
    2: .same(proto: "NEW_SONG"),
    3: .same(proto: "CHILDREN"),
    4: .same(proto: "HOWARD_HIGASHI"),
    5: .same(proto: "DUTCH"),
    6: .same(proto: "GERMAN"),
    7: .same(proto: "CHINESE"),
    8: .same(proto: "CHINESE_SIMPLIFIED"),
    9: .same(proto: "CHINESE_SUPPLEMENTAL"),
    10: .same(proto: "CHINESE_SUPPLEMENTAL_SIMPLIFIED"),
    11: .same(proto: "CEBUANO"),
    12: .same(proto: "TAGALOG"),
    13: .same(proto: "FRENCH"),
    14: .same(proto: "SPANISH"),
    15: .same(proto: "KOREAN"),
    16: .same(proto: "JAPANESE"),
    17: .same(proto: "INDONESIAN"),
    18: .same(proto: "FARSI"),
    19: .same(proto: "RUSSIAN"),
    20: .same(proto: "PORTUGUESE"),
    21: .same(proto: "BE_FILLED"),
    22: .same(proto: "LIEDERBUCH"),
    23: .same(proto: "HINOS"),
    24: .same(proto: "HEBREW"),
    25: .same(proto: "SLOVAK"),
    26: .same(proto: "ESTONIAN"),
    27: .same(proto: "ARABIC"),
    28: .same(proto: "BLUE_SONGBOOK"),
    29: .same(proto: "LIEDBOEK"),
    30: .same(proto: "SONGBASE_OTHER"),
  ]
}

extension VerseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERSE"),
    1: .same(proto: "CHORUS"),
    2: .same(proto: "OTHER"),
    3: .same(proto: "COPYRIGHT"),
    4: .same(proto: "NOTE"),
    5: .same(proto: "DO_NOT_DISPLAY"),
  ]
}

extension Language: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LANGUAGE_ENGLISH"),
    1: .same(proto: "LANGUAGE_DUTCH"),
    2: .same(proto: "LANGUAGE_GERMAN"),
    3: .same(proto: "LANGUAGE_CHINESE_TRADITIONAL"),
    4: .same(proto: "LANGUAGE_CHINESE_SIMPLIFIED"),
    5: .same(proto: "LANGUAGE_CEBUANO"),
    6: .same(proto: "LANGUAGE_TAGALOG"),
    7: .same(proto: "LANGUAGE_FRENCH"),
    8: .same(proto: "LANGUAGE_SPANISH"),
    9: .same(proto: "LANGUAGE_KOREAN"),
    10: .same(proto: "LANGUAGE_JAPANESE"),
    11: .same(proto: "LANGUAGE_FARSI"),
    12: .same(proto: "LANGUAGE_RUSSIAN"),
    13: .same(proto: "LANGUAGE_PORTUGUESE"),
    14: .same(proto: "LANGUAGE_HEBREW"),
    15: .same(proto: "LANGUAGE_SLOVAK"),
    16: .same(proto: "LANGUAGE_ESTONIAN"),
    17: .same(proto: "LANGUAGE_ARABIC"),
    18: .same(proto: "LANGUAGE_INDONESIAN"),
  ]
}

extension HymnEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HymnEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "references"),
    3: .same(proto: "title"),
    4: .same(proto: "lyrics"),
    5: .same(proto: "category"),
    6: .same(proto: "subcategory"),
    7: .same(proto: "author"),
    8: .same(proto: "composer"),
    9: .same(proto: "key"),
    10: .same(proto: "time"),
    11: .same(proto: "meter"),
    12: .same(proto: "scriptures"),
    13: .standard(proto: "hymn_code"),
    14: .same(proto: "music"),
    15: .standard(proto: "svg_sheet"),
    16: .standard(proto: "pdf_sheet"),
    21: .same(proto: "languages"),
    22: .same(proto: "relevants"),
    19: .standard(proto: "inline_chords"),
    20: .same(proto: "provenance"),
    23: .standard(proto: "flattened_lyrics"),
    24: .same(proto: "language"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _references: [HymnIdentifierEntity] = []
    var _title: String = String()
    var _lyrics: LyricsEntity? = nil
    var _category: [String] = []
    var _subcategory: [String] = []
    var _author: [String] = []
    var _composer: [String] = []
    var _key: [String] = []
    var _time: [String] = []
    var _meter: [String] = []
    var _scriptures: [String] = []
    var _hymnCode: [String] = []
    var _music: MusicEntity? = nil
    var _svgSheet: SvgSheetEntity? = nil
    var _pdfSheet: PdfSheetEntity? = nil
    var _languages: LanguagesEntity? = nil
    var _relevants: RelevantsEntity? = nil
    var _inlineChords: InlineChordsEntity? = nil
    var _provenance: [String] = []
    var _flattenedLyrics: String = String()
    var _language: Language = .english

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _references = source._references
      _title = source._title
      _lyrics = source._lyrics
      _category = source._category
      _subcategory = source._subcategory
      _author = source._author
      _composer = source._composer
      _key = source._key
      _time = source._time
      _meter = source._meter
      _scriptures = source._scriptures
      _hymnCode = source._hymnCode
      _music = source._music
      _svgSheet = source._svgSheet
      _pdfSheet = source._pdfSheet
      _languages = source._languages
      _relevants = source._relevants
      _inlineChords = source._inlineChords
      _provenance = source._provenance
      _flattenedLyrics = source._flattenedLyrics
      _language = source._language
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._references) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lyrics) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._category) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._subcategory) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._author) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._composer) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._key) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._time) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._meter) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._scriptures) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._hymnCode) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._music) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._svgSheet) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._pdfSheet) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._inlineChords) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._provenance) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._languages) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._relevants) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._flattenedLyrics) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._language) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._references.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._references, fieldNumber: 2)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 3)
      }
      try { if let v = _storage._lyrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._category.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._category, fieldNumber: 5)
      }
      if !_storage._subcategory.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._subcategory, fieldNumber: 6)
      }
      if !_storage._author.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._author, fieldNumber: 7)
      }
      if !_storage._composer.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._composer, fieldNumber: 8)
      }
      if !_storage._key.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._key, fieldNumber: 9)
      }
      if !_storage._time.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._time, fieldNumber: 10)
      }
      if !_storage._meter.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._meter, fieldNumber: 11)
      }
      if !_storage._scriptures.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._scriptures, fieldNumber: 12)
      }
      if !_storage._hymnCode.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._hymnCode, fieldNumber: 13)
      }
      try { if let v = _storage._music {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._svgSheet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._pdfSheet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._inlineChords {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if !_storage._provenance.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._provenance, fieldNumber: 20)
      }
      try { if let v = _storage._languages {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._relevants {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._flattenedLyrics.isEmpty {
        try visitor.visitSingularStringField(value: _storage._flattenedLyrics, fieldNumber: 23)
      }
      if _storage._language != .english {
        try visitor.visitSingularEnumField(value: _storage._language, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HymnEntity, rhs: HymnEntity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._references != rhs_storage._references {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._lyrics != rhs_storage._lyrics {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._subcategory != rhs_storage._subcategory {return false}
        if _storage._author != rhs_storage._author {return false}
        if _storage._composer != rhs_storage._composer {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._meter != rhs_storage._meter {return false}
        if _storage._scriptures != rhs_storage._scriptures {return false}
        if _storage._hymnCode != rhs_storage._hymnCode {return false}
        if _storage._music != rhs_storage._music {return false}
        if _storage._svgSheet != rhs_storage._svgSheet {return false}
        if _storage._pdfSheet != rhs_storage._pdfSheet {return false}
        if _storage._languages != rhs_storage._languages {return false}
        if _storage._relevants != rhs_storage._relevants {return false}
        if _storage._inlineChords != rhs_storage._inlineChords {return false}
        if _storage._provenance != rhs_storage._provenance {return false}
        if _storage._flattenedLyrics != rhs_storage._flattenedLyrics {return false}
        if _storage._language != rhs_storage._language {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HymnIdentifierEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HymnIdentifierEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hymn_type"),
    2: .standard(proto: "hymn_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hymnType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hymnNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hymnType != .classic {
      try visitor.visitSingularEnumField(value: self.hymnType, fieldNumber: 1)
    }
    if !self.hymnNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.hymnNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HymnIdentifierEntity, rhs: HymnIdentifierEntity) -> Bool {
    if lhs.hymnType != rhs.hymnType {return false}
    if lhs.hymnNumber != rhs.hymnNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LyricsEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LyricsEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.verses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.verses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.verses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LyricsEntity, rhs: LyricsEntity) -> Bool {
    if lhs.verses != rhs.verses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VerseEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VerseEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "verse_type"),
    2: .same(proto: "lines"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.verseType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lines) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verseType != .verse {
      try visitor.visitSingularEnumField(value: self.verseType, fieldNumber: 1)
    }
    if !self.lines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lines, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VerseEntity, rhs: VerseEntity) -> Bool {
    if lhs.verseType != rhs.verseType {return false}
    if lhs.lines != rhs.lines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LineEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LineEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "line_content"),
    2: .same(proto: "transliteration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lineContent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._transliteration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.lineContent.isEmpty {
      try visitor.visitSingularStringField(value: self.lineContent, fieldNumber: 1)
    }
    try { if let v = self._transliteration {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LineEntity, rhs: LineEntity) -> Bool {
    if lhs.lineContent != rhs.lineContent {return false}
    if lhs._transliteration != rhs._transliteration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InlineChordsEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InlineChordsEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chordLines"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chordLines) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chordLines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chordLines, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InlineChordsEntity, rhs: InlineChordsEntity) -> Bool {
    if lhs.chordLines != rhs.chordLines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChordLineEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChordLineEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chord_words"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chordWords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chordWords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chordWords, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChordLineEntity, rhs: ChordLineEntity) -> Bool {
    if lhs.chordWords != rhs.chordWords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChordWordEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChordWordEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "chords"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.word) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._chords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    try { if let v = self._chords {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChordWordEntity, rhs: ChordWordEntity) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs._chords != rhs._chords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MusicEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MusicEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "music"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.music) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.music.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.music, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MusicEntity, rhs: MusicEntity) -> Bool {
    if lhs.music != rhs.music {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SvgSheetEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SvgSheetEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "svg_sheet"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.svgSheet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.svgSheet.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.svgSheet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SvgSheetEntity, rhs: SvgSheetEntity) -> Bool {
    if lhs.svgSheet != rhs.svgSheet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PdfSheetEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PdfSheetEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pdf_sheet"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.pdfSheet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pdfSheet.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.pdfSheet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PdfSheetEntity, rhs: PdfSheetEntity) -> Bool {
    if lhs.pdfSheet != rhs.pdfSheet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LanguagesEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LanguagesEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "languages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.languages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.languages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LanguagesEntity, rhs: LanguagesEntity) -> Bool {
    if lhs.languages != rhs.languages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RelevantsEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RelevantsEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "relevants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.relevants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.relevants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relevants, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RelevantsEntity, rhs: RelevantsEntity) -> Bool {
    if lhs.relevants != rhs.relevants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

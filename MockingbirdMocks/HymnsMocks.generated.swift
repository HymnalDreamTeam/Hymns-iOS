//
//  HymnsMocks.generated.swift
//  Hymns
//
//  Generated by Mockingbird v0.10.0.
//  DO NOT EDIT
//

// swiftlint:disable all

@testable import Hymns
@testable import Mockingbird
import Combine
import Foundation
import Resolver
import Swift
import SwiftUI

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked HymnLyricsViewModel

public final class HymnLyricsViewModelMock: Hymns.HymnLyricsViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnLyricsViewModelMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`hymnsRepository`: Hymns.HymnsRepository, __file: StaticString = #file, __line: UInt = #line) -> HymnLyricsViewModelMock {
      let mock: HymnLyricsViewModelMock = HymnLyricsViewModelMock(hymnsRepository: `hymnsRepository`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked lyrics

  override public var `lyrics`: [Verse]? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Verse]?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Verse]?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLyrics() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Verse]?, [Verse]?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Verse]?, [Verse]?>(mock: self, invocation: invocation)
  }

  public func setLyrics(_ newValue: @escaping @autoclosure () -> [Verse]?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Verse]?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Verse]?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`hymnsRepository`: Hymns.HymnsRepository)

  public required override init(`hymnsRepository`: Hymns.HymnsRepository) {
    super.init(hymnsRepository: `hymnsRepository`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`hymnsRepository`: Hymns.HymnsRepository) ", arguments: [Mockingbird.ArgumentMatcher(`hymnsRepository`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnLyricsViewModel` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnLyricsViewModel.Type) -> HymnLyricsViewModelMock.InitializerProxy.Type {
  return HymnLyricsViewModelMock.InitializerProxy.self
}

// MARK: - Mocked HymnalApiServiceImpl

public final class HymnalApiServiceImplMock: Hymns.HymnalApiServiceImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnalApiServiceImplMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`decoder`: JSONDecoder, `session`: URLSession, __file: StaticString = #file, __line: UInt = #line) -> HymnalApiServiceImplMock {
      let mock: HymnalApiServiceImplMock = HymnalApiServiceImplMock(decoder: `decoder`, session: `session`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?)

  public override func `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>", arguments: [Mockingbird.ArgumentMatcher(`hymnType`), Mockingbird.ArgumentMatcher(`hymnNumber`), Mockingbird.ArgumentMatcher(`queryParams`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType> {
      return concreteImplementation(`hymnType`, `hymnNumber`, `queryParams`)
    } else {
      return (implementation as! () -> AnyPublisher<Hymn, Hymns.ErrorType>)()
    }
  }

  public func `getHymn`(`hymnType`: @escaping @autoclosure () -> HymnType, `hymnNumber`: @escaping @autoclosure () -> String, `queryParams`: @escaping @autoclosure () -> [String: String]?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>, AnyPublisher<Hymn, Hymns.ErrorType>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnType`), Mockingbird.resolve(`hymnNumber`), Mockingbird.resolve(`queryParams`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>, AnyPublisher<Hymn, Hymns.ErrorType>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`decoder`: JSONDecoder, `session`: URLSession)

  public required override init(`decoder`: JSONDecoder, `session`: URLSession) {
    super.init(decoder: `decoder`, session: `session`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`decoder`: JSONDecoder, `session`: URLSession) ", arguments: [Mockingbird.ArgumentMatcher(`decoder`), Mockingbird.ArgumentMatcher(`session`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnalApiServiceImpl` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnalApiServiceImpl.Type) -> HymnalApiServiceImplMock.InitializerProxy.Type {
  return HymnalApiServiceImplMock.InitializerProxy.self
}

// MARK: - Mocked HymnalApiService

public final class HymnalApiServiceMock: Hymns.HymnalApiService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnalApiServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?)

  public func `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>", arguments: [Mockingbird.ArgumentMatcher(`hymnType`), Mockingbird.ArgumentMatcher(`hymnNumber`), Mockingbird.ArgumentMatcher(`queryParams`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType> {
      return concreteImplementation(`hymnType`, `hymnNumber`, `queryParams`)
    } else {
      return (implementation as! () -> AnyPublisher<Hymn, Hymns.ErrorType>)()
    }
  }

  public func `getHymn`(`hymnType`: @escaping @autoclosure () -> HymnType, `hymnNumber`: @escaping @autoclosure () -> String, `queryParams`: @escaping @autoclosure () -> [String: String]?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>, AnyPublisher<Hymn, Hymns.ErrorType>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnType`), Mockingbird.resolve(`hymnNumber`), Mockingbird.resolve(`queryParams`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>, AnyPublisher<Hymn, Hymns.ErrorType>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Hymns.HymnalApiService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnalApiService.Protocol) -> HymnalApiServiceMock {
  return HymnalApiServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked HymnsRepositoryImpl

public final class HymnsRepositoryImplMock: Hymns.HymnsRepositoryImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnsRepositoryImplMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`hymnalApiService`: Hymns.HymnalApiService, __file: StaticString = #file, __line: UInt = #line) -> HymnsRepositoryImplMock {
      let mock: HymnsRepositoryImplMock = HymnsRepositoryImplMock(hymnalApiService: `hymnalApiService`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `getHymn`(`hymnIdentifier`: HymnIdentifier)

  public override func `getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never>", arguments: [Mockingbird.ArgumentMatcher(`hymnIdentifier`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HymnIdentifier) -> AnyPublisher<Hymn?, Never> {
      return concreteImplementation(`hymnIdentifier`)
    } else {
      return (implementation as! () -> AnyPublisher<Hymn?, Never>)()
    }
  }

  public func `getHymn`(`hymnIdentifier`: @escaping @autoclosure () -> HymnIdentifier) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier) -> AnyPublisher<Hymn?, Never>, AnyPublisher<Hymn?, Never>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnIdentifier`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier) -> AnyPublisher<Hymn?, Never>, AnyPublisher<Hymn?, Never>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`hymnalApiService`: Hymns.HymnalApiService)

  public required override init(`hymnalApiService`: Hymns.HymnalApiService) {
    super.init(hymnalApiService: `hymnalApiService`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`hymnalApiService`: Hymns.HymnalApiService) ", arguments: [Mockingbird.ArgumentMatcher(`hymnalApiService`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnsRepositoryImpl` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnsRepositoryImpl.Type) -> HymnsRepositoryImplMock.InitializerProxy.Type {
  return HymnsRepositoryImplMock.InitializerProxy.self
}

// MARK: - Mocked HymnsRepository

public final class HymnsRepositoryMock: Hymns.HymnsRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnsRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getHymn`(`hymnIdentifier`: HymnIdentifier)

  public func `getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never>", arguments: [Mockingbird.ArgumentMatcher(`hymnIdentifier`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HymnIdentifier) -> AnyPublisher<Hymn?, Never> {
      return concreteImplementation(`hymnIdentifier`)
    } else {
      return (implementation as! () -> AnyPublisher<Hymn?, Never>)()
    }
  }

  public func `getHymn`(`hymnIdentifier`: @escaping @autoclosure () -> HymnIdentifier) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier) -> AnyPublisher<Hymn?, Never>, AnyPublisher<Hymn?, Never>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnIdentifier`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier) -> AnyPublisher<Hymn?, Never>, AnyPublisher<Hymn?, Never>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Hymns.HymnsRepository` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnsRepository.Protocol) -> HymnsRepositoryMock {
  return HymnsRepositoryMock(sourceLocation: SourceLocation(file, line))
}

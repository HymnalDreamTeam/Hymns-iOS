//
//  HymnsMocks.generated.swift
//  Hymns
//
//  Generated by Mockingbird v0.10.0.
//  DO NOT EDIT
//

// swiftlint:disable all

@testable import Hymns
@testable import Mockingbird
import Combine
import Foundation
import Resolver
import Swift
import SwiftUI

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked HomeViewModel

public final class HomeViewModelMock: Hymns.HomeViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HomeViewModelMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`recentSongs`: [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>], __file: StaticString = #file, __line: UInt = #line) -> HomeViewModelMock {
      let mock: HomeViewModelMock = HomeViewModelMock(recentSongs: `recentSongs`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked recentSongs

  override public var `recentSongs`: [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "recentSongs.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>])()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "recentSongs.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getRecentSongs() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>], [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "recentSongs.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>], [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]>(mock: self, invocation: invocation)
  }

  public func setRecentSongs(_ newValue: @escaping @autoclosure () -> [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "recentSongs.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`recentSongs`: [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>])

  public required override init(`recentSongs`: [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) {
    super.init(recentSongs: `recentSongs`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`recentSongs`: [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) ", arguments: [Mockingbird.ArgumentMatcher(`recentSongs`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HomeViewModel` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HomeViewModel.Type) -> HomeViewModelMock.InitializerProxy.Type {
  return HomeViewModelMock.InitializerProxy.self
}

// MARK: - Mocked HymnLyricsViewModel

public final class HymnLyricsViewModelMock: Hymns.HymnLyricsViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnLyricsViewModelMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`hymnToDisplay` `identifier`: HymnIdentifier, `hymnsRepository`: Hymns.HymnsRepository, `mainQueue`: DispatchQueue, __file: StaticString = #file, __line: UInt = #line) -> HymnLyricsViewModelMock {
      let mock: HymnLyricsViewModelMock = HymnLyricsViewModelMock(hymnToDisplay: `identifier`, hymnsRepository: `hymnsRepository`, mainQueue: `mainQueue`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked lyrics

  override public var `lyrics`: [Verse]? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Verse]?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Verse]?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLyrics() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Verse]?, [Verse]?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Verse]?, [Verse]?>(mock: self, invocation: invocation)
  }

  public func setLyrics(_ newValue: @escaping @autoclosure () -> [Verse]?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Verse]?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Verse]?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`hymnToDisplay` `identifier`: HymnIdentifier, `hymnsRepository`: Hymns.HymnsRepository, `mainQueue`: DispatchQueue)

  public required override init(`hymnToDisplay` `identifier`: HymnIdentifier, `hymnsRepository`: Hymns.HymnsRepository, `mainQueue`: DispatchQueue) {
    super.init(hymnToDisplay: `identifier`, hymnsRepository: `hymnsRepository`, mainQueue: `mainQueue`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`hymnToDisplay` `identifier`: HymnIdentifier, `hymnsRepository`: Hymns.HymnsRepository, `mainQueue`: DispatchQueue) ", arguments: [Mockingbird.ArgumentMatcher(`identifier`), Mockingbird.ArgumentMatcher(`hymnsRepository`), Mockingbird.ArgumentMatcher(`mainQueue`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnLyricsViewModel` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnLyricsViewModel.Type) -> HymnLyricsViewModelMock.InitializerProxy.Type {
  return HymnLyricsViewModelMock.InitializerProxy.self
}

// MARK: - Mocked HymnalApiServiceImpl

public final class HymnalApiServiceImplMock: Hymns.HymnalApiServiceImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnalApiServiceImplMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`decoder`: JSONDecoder, `session`: URLSession, __file: StaticString = #file, __line: UInt = #line) -> HymnalApiServiceImplMock {
      let mock: HymnalApiServiceImplMock = HymnalApiServiceImplMock(decoder: `decoder`, session: `session`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?)

  public override func `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>", arguments: [Mockingbird.ArgumentMatcher(`hymnType`), Mockingbird.ArgumentMatcher(`hymnNumber`), Mockingbird.ArgumentMatcher(`queryParams`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType> {
      return concreteImplementation(`hymnType`, `hymnNumber`, `queryParams`)
    } else {
      return (implementation as! () -> AnyPublisher<Hymn, Hymns.ErrorType>)()
    }
  }

  public func `getHymn`(`hymnType`: @escaping @autoclosure () -> HymnType, `hymnNumber`: @escaping @autoclosure () -> String, `queryParams`: @escaping @autoclosure () -> [String: String]?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>, AnyPublisher<Hymn, Hymns.ErrorType>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnType`), Mockingbird.resolve(`hymnNumber`), Mockingbird.resolve(`queryParams`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>, AnyPublisher<Hymn, Hymns.ErrorType>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`decoder`: JSONDecoder, `session`: URLSession)

  public required override init(`decoder`: JSONDecoder, `session`: URLSession) {
    super.init(decoder: `decoder`, session: `session`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`decoder`: JSONDecoder, `session`: URLSession) ", arguments: [Mockingbird.ArgumentMatcher(`decoder`), Mockingbird.ArgumentMatcher(`session`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `search`(`for` `searchInput`: String, `onPage` `pageNumber`: Int?)

  public override func `search`(`for` `searchInput`: String, `onPage` `pageNumber`: Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`search`(`for` `searchInput`: String, `onPage` `pageNumber`: Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType>", arguments: [Mockingbird.ArgumentMatcher(`searchInput`), Mockingbird.ArgumentMatcher(`pageNumber`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String, Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType> {
      return concreteImplementation(`searchInput`, `pageNumber`)
    } else {
      return (implementation as! () -> AnyPublisher<SongResultsPage, Hymns.ErrorType>)()
    }
  }

  public func `search`(`for` `searchInput`: @escaping @autoclosure () -> String, `onPage` `pageNumber`: @escaping @autoclosure () -> Int?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType>, AnyPublisher<SongResultsPage, Hymns.ErrorType>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`searchInput`), Mockingbird.resolve(`pageNumber`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`search`(`for` `searchInput`: String, `onPage` `pageNumber`: Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType>, AnyPublisher<SongResultsPage, Hymns.ErrorType>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Hymns.HymnalApiServiceImpl` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnalApiServiceImpl.Type) -> HymnalApiServiceImplMock.InitializerProxy.Type {
  return HymnalApiServiceImplMock.InitializerProxy.self
}

// MARK: - Mocked HymnalApiService

public final class HymnalApiServiceMock: Hymns.HymnalApiService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnalApiServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?)

  public func `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>", arguments: [Mockingbird.ArgumentMatcher(`hymnType`), Mockingbird.ArgumentMatcher(`hymnNumber`), Mockingbird.ArgumentMatcher(`queryParams`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType> {
      return concreteImplementation(`hymnType`, `hymnNumber`, `queryParams`)
    } else {
      return (implementation as! () -> AnyPublisher<Hymn, Hymns.ErrorType>)()
    }
  }

  public func `getHymn`(`hymnType`: @escaping @autoclosure () -> HymnType, `hymnNumber`: @escaping @autoclosure () -> String, `queryParams`: @escaping @autoclosure () -> [String: String]?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>, AnyPublisher<Hymn, Hymns.ErrorType>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnType`), Mockingbird.resolve(`hymnNumber`), Mockingbird.resolve(`queryParams`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?) -> AnyPublisher<Hymn, Hymns.ErrorType>, AnyPublisher<Hymn, Hymns.ErrorType>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `search`(`for` `searchInput`: String, `onPage` `pageNumber`: Int?)

  public func `search`(`for` `searchInput`: String, `onPage` `pageNumber`: Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`search`(`for` `searchInput`: String, `onPage` `pageNumber`: Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType>", arguments: [Mockingbird.ArgumentMatcher(`searchInput`), Mockingbird.ArgumentMatcher(`pageNumber`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String, Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType> {
      return concreteImplementation(`searchInput`, `pageNumber`)
    } else {
      return (implementation as! () -> AnyPublisher<SongResultsPage, Hymns.ErrorType>)()
    }
  }

  public func `search`(`for` `searchInput`: @escaping @autoclosure () -> String, `onPage` `pageNumber`: @escaping @autoclosure () -> Int?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType>, AnyPublisher<SongResultsPage, Hymns.ErrorType>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`searchInput`), Mockingbird.resolve(`pageNumber`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`search`(`for` `searchInput`: String, `onPage` `pageNumber`: Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, Int?) -> AnyPublisher<SongResultsPage, Hymns.ErrorType>, AnyPublisher<SongResultsPage, Hymns.ErrorType>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Hymns.HymnalApiService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnalApiService.Protocol) -> HymnalApiServiceMock {
  return HymnalApiServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked HymnsRepositoryImpl

public final class HymnsRepositoryImplMock: Hymns.HymnsRepositoryImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnsRepositoryImplMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`hymnalApiService`: Hymns.HymnalApiService, __file: StaticString = #file, __line: UInt = #line) -> HymnsRepositoryImplMock {
      let mock: HymnsRepositoryImplMock = HymnsRepositoryImplMock(hymnalApiService: `hymnalApiService`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `getHymn`(`hymnIdentifier`: HymnIdentifier)

  public override func `getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never>", arguments: [Mockingbird.ArgumentMatcher(`hymnIdentifier`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HymnIdentifier) -> AnyPublisher<Hymn?, Never> {
      return concreteImplementation(`hymnIdentifier`)
    } else {
      return (implementation as! () -> AnyPublisher<Hymn?, Never>)()
    }
  }

  public func `getHymn`(`hymnIdentifier`: @escaping @autoclosure () -> HymnIdentifier) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier) -> AnyPublisher<Hymn?, Never>, AnyPublisher<Hymn?, Never>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnIdentifier`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier) -> AnyPublisher<Hymn?, Never>, AnyPublisher<Hymn?, Never>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`hymnalApiService`: Hymns.HymnalApiService)

  public required override init(`hymnalApiService`: Hymns.HymnalApiService) {
    super.init(hymnalApiService: `hymnalApiService`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`hymnalApiService`: Hymns.HymnalApiService) ", arguments: [Mockingbird.ArgumentMatcher(`hymnalApiService`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnsRepositoryImpl` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnsRepositoryImpl.Type) -> HymnsRepositoryImplMock.InitializerProxy.Type {
  return HymnsRepositoryImplMock.InitializerProxy.self
}

// MARK: - Mocked HymnsRepository

public final class HymnsRepositoryMock: Hymns.HymnsRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnsRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getHymn`(`hymnIdentifier`: HymnIdentifier)

  public func `getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never>", arguments: [Mockingbird.ArgumentMatcher(`hymnIdentifier`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HymnIdentifier) -> AnyPublisher<Hymn?, Never> {
      return concreteImplementation(`hymnIdentifier`)
    } else {
      return (implementation as! () -> AnyPublisher<Hymn?, Never>)()
    }
  }

  public func `getHymn`(`hymnIdentifier`: @escaping @autoclosure () -> HymnIdentifier) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier) -> AnyPublisher<Hymn?, Never>, AnyPublisher<Hymn?, Never>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnIdentifier`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier) -> AnyPublisher<Hymn?, Never>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier) -> AnyPublisher<Hymn?, Never>, AnyPublisher<Hymn?, Never>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Hymns.HymnsRepository` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnsRepository.Protocol) -> HymnsRepositoryMock {
  return HymnsRepositoryMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SearchViewModel

public final class SearchViewModelMock: Hymns.SearchViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SearchViewModelMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`backgroundQueue`: DispatchQueue, `mainQueue`: DispatchQueue, `repository`: Hymns.SongResultsRepository, __file: StaticString = #file, __line: UInt = #line) -> SearchViewModelMock {
      let mock: SearchViewModelMock = SearchViewModelMock(backgroundQueue: `backgroundQueue`, mainQueue: `mainQueue`, repository: `repository`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked searchInput

  override public var `searchInput`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "searchInput.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "searchInput.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSearchInput() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "searchInput.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  public func setSearchInput(_ newValue: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "searchInput.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked songResults

  override public var `songResults`: [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "songResults.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>])()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "songResults.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSongResults() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>], [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "songResults.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>], [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]>(mock: self, invocation: invocation)
  }

  public func setSongResults(_ newValue: @escaping @autoclosure () -> [Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "songResults.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Hymns.SongResultViewModel<Hymns.DetailHymnScreen>]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`backgroundQueue`: DispatchQueue, `mainQueue`: DispatchQueue, `repository`: Hymns.SongResultsRepository)

  public required override init(`backgroundQueue`: DispatchQueue, `mainQueue`: DispatchQueue, `repository`: Hymns.SongResultsRepository) {
    super.init(backgroundQueue: `backgroundQueue`, mainQueue: `mainQueue`, repository: `repository`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`backgroundQueue`: DispatchQueue, `mainQueue`: DispatchQueue, `repository`: Hymns.SongResultsRepository) ", arguments: [Mockingbird.ArgumentMatcher(`backgroundQueue`), Mockingbird.ArgumentMatcher(`mainQueue`), Mockingbird.ArgumentMatcher(`repository`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.SearchViewModel` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.SearchViewModel.Type) -> SearchViewModelMock.InitializerProxy.Type {
  return SearchViewModelMock.InitializerProxy.self
}

// MARK: - Mocked SongResultViewModel

public final class SongResultViewModelMock<DestinationView>: Hymns.SongResultViewModel<DestinationView>, Mockingbird.Mock where DestinationView: View {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(DestinationView.self)"].joined(separator: ",")
    let staticMockIdentifier = "SongResultViewModelMock<DestinationView>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SongResultViewModelMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`title`: String, `destinationView`: DestinationView, __file: StaticString = #file, __line: UInt = #line) -> SongResultViewModelMock<DestinationView> {
      let mock: SongResultViewModelMock<DestinationView> = SongResultViewModelMock<DestinationView>(title: `title`, destinationView: `destinationView`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`title`: String, `destinationView`: DestinationView)

  public required override init(`title`: String, `destinationView`: DestinationView) {
    super.init(title: `title`, destinationView: `destinationView`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`title`: String, `destinationView`: DestinationView) ", arguments: [Mockingbird.ArgumentMatcher(`title`), Mockingbird.ArgumentMatcher(`destinationView`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.SongResultViewModel<DestinationView><DestinationView>` class mock metatype.
public func mock<DestinationView>(file: StaticString = #file, line: UInt = #line, _ type: SongResultViewModelMock<DestinationView>.Type) -> SongResultViewModelMock<DestinationView>.InitializerProxy.Type {
  return SongResultViewModelMock<DestinationView>.InitializerProxy.self
}

// MARK: - Mocked SongResultsRepositoryImpl

public final class SongResultsRepositoryImplMock: Hymns.SongResultsRepositoryImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SongResultsRepositoryImplMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`hymnalApiService`: Hymns.HymnalApiService, __file: StaticString = #file, __line: UInt = #line) -> SongResultsRepositoryImplMock {
      let mock: SongResultsRepositoryImplMock = SongResultsRepositoryImplMock(hymnalApiService: `hymnalApiService`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`hymnalApiService`: Hymns.HymnalApiService)

  public required override init(`hymnalApiService`: Hymns.HymnalApiService) {
    super.init(hymnalApiService: `hymnalApiService`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`hymnalApiService`: Hymns.HymnalApiService) ", arguments: [Mockingbird.ArgumentMatcher(`hymnalApiService`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `search`(`searchInput`: String, `pageNumber`: Int?)

  public override func `search`(`searchInput`: String, `pageNumber`: Int?) -> AnyPublisher<SongResultsPage?, Never> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`search`(`searchInput`: String, `pageNumber`: Int?) -> AnyPublisher<SongResultsPage?, Never>", arguments: [Mockingbird.ArgumentMatcher(`searchInput`), Mockingbird.ArgumentMatcher(`pageNumber`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String, Int?) -> AnyPublisher<SongResultsPage?, Never> {
      return concreteImplementation(`searchInput`, `pageNumber`)
    } else {
      return (implementation as! () -> AnyPublisher<SongResultsPage?, Never>)()
    }
  }

  public func `search`(`searchInput`: @escaping @autoclosure () -> String, `pageNumber`: @escaping @autoclosure () -> Int?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, Int?) -> AnyPublisher<SongResultsPage?, Never>, AnyPublisher<SongResultsPage?, Never>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`searchInput`), Mockingbird.resolve(`pageNumber`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`search`(`searchInput`: String, `pageNumber`: Int?) -> AnyPublisher<SongResultsPage?, Never>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, Int?) -> AnyPublisher<SongResultsPage?, Never>, AnyPublisher<SongResultsPage?, Never>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Hymns.SongResultsRepositoryImpl` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.SongResultsRepositoryImpl.Type) -> SongResultsRepositoryImplMock.InitializerProxy.Type {
  return SongResultsRepositoryImplMock.InitializerProxy.self
}

// MARK: - Mocked SongResultsRepository

public final class SongResultsRepositoryMock: Hymns.SongResultsRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SongResultsRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `search`(`searchInput`: String, `pageNumber`: Int?)

  public func `search`(`searchInput`: String, `pageNumber`: Int?) -> AnyPublisher<SongResultsPage?, Never> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`search`(`searchInput`: String, `pageNumber`: Int?) -> AnyPublisher<SongResultsPage?, Never>", arguments: [Mockingbird.ArgumentMatcher(`searchInput`), Mockingbird.ArgumentMatcher(`pageNumber`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String, Int?) -> AnyPublisher<SongResultsPage?, Never> {
      return concreteImplementation(`searchInput`, `pageNumber`)
    } else {
      return (implementation as! () -> AnyPublisher<SongResultsPage?, Never>)()
    }
  }

  public func `search`(`searchInput`: @escaping @autoclosure () -> String, `pageNumber`: @escaping @autoclosure () -> Int?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, Int?) -> AnyPublisher<SongResultsPage?, Never>, AnyPublisher<SongResultsPage?, Never>> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`searchInput`), Mockingbird.resolve(`pageNumber`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`search`(`searchInput`: String, `pageNumber`: Int?) -> AnyPublisher<SongResultsPage?, Never>", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, Int?) -> AnyPublisher<SongResultsPage?, Never>, AnyPublisher<SongResultsPage?, Never>>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Hymns.SongResultsRepository` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.SongResultsRepository.Protocol) -> SongResultsRepositoryMock {
  return SongResultsRepositoryMock(sourceLocation: SourceLocation(file, line))
}

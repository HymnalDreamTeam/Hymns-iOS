//
//  HymnsMocks.generated.swift
//  Hymns
//
//  Generated by Mockingbird v0.10.0.
//  DO NOT EDIT
//

// swiftlint:disable all

@testable import Hymns
@testable import Mockingbird
import Alamofire
import Foundation
import Resolver
import Swift
import SwiftUI

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked HymnLyricsViewModel

public final class HymnLyricsViewModelMock: Hymns.HymnLyricsViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnLyricsViewModelMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`hymnsRepository`: Hymns.HymnsRepository, __file: StaticString = #file, __line: UInt = #line) -> HymnLyricsViewModelMock {
      let mock: HymnLyricsViewModelMock = HymnLyricsViewModelMock(hymnsRepository: `hymnsRepository`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked lyrics

  override public var `lyrics`: [Verse]? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Verse]?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Verse]?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLyrics() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Verse]?, [Verse]?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Verse]?, [Verse]?>(mock: self, invocation: invocation)
  }

  public func setLyrics(_ newValue: @escaping @autoclosure () -> [Verse]?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Verse]?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Verse]?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`hymnsRepository`: Hymns.HymnsRepository)

  public required override init(`hymnsRepository`: Hymns.HymnsRepository) {
    super.init(hymnsRepository: `hymnsRepository`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`hymnsRepository`: Hymns.HymnsRepository) ", arguments: [Mockingbird.ArgumentMatcher(`hymnsRepository`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnLyricsViewModel` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnLyricsViewModel.Type) -> HymnLyricsViewModelMock.InitializerProxy.Type {
  return HymnLyricsViewModelMock.InitializerProxy.self
}

// MARK: - Mocked HymnalApiServiceAlamofireImpl

public final class HymnalApiServiceAlamofireImplMock: Hymns.HymnalApiServiceAlamofireImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnalApiServiceAlamofireImplMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`jsonDecoder`: JSONDecoder, __file: StaticString = #file, __line: UInt = #line) -> HymnalApiServiceAlamofireImplMock {
      let mock: HymnalApiServiceAlamofireImplMock = HymnalApiServiceAlamofireImplMock(jsonDecoder: `jsonDecoder`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void)

  public override func `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hymnType`), Mockingbird.ArgumentMatcher(`hymnNumber`), Mockingbird.ArgumentMatcher(`queryParams`), Mockingbird.ArgumentMatcher(`callback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HymnType, String, [String: String]?, @escaping (Hymn?) -> Void) -> Void {
      concreteImplementation(`hymnType`, `hymnNumber`, `queryParams`, `callback`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `getHymn`(`hymnType`: @escaping @autoclosure () -> HymnType, `hymnNumber`: @escaping @autoclosure () -> String, `queryParams`: @escaping @autoclosure () -> [String: String]?, _ `callback`: @escaping @autoclosure () -> (Hymn?) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?, @escaping (Hymn?) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnType`), Mockingbird.resolve(`hymnNumber`), Mockingbird.resolve(`queryParams`), Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?, @escaping (Hymn?) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`jsonDecoder`: JSONDecoder)

  public required override init(`jsonDecoder`: JSONDecoder) {
    super.init(jsonDecoder: `jsonDecoder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`jsonDecoder`: JSONDecoder) ", arguments: [Mockingbird.ArgumentMatcher(`jsonDecoder`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnalApiServiceAlamofireImpl` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnalApiServiceAlamofireImpl.Type) -> HymnalApiServiceAlamofireImplMock.InitializerProxy.Type {
  return HymnalApiServiceAlamofireImplMock.InitializerProxy.self
}

// MARK: - Mocked HymnalApiService

public final class HymnalApiServiceMock: Hymns.HymnalApiService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnalApiServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void)

  public func `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hymnType`), Mockingbird.ArgumentMatcher(`hymnNumber`), Mockingbird.ArgumentMatcher(`queryParams`), Mockingbird.ArgumentMatcher(`callback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HymnType, String, [String: String]?, @escaping (Hymn?) -> Void) -> Void {
      concreteImplementation(`hymnType`, `hymnNumber`, `queryParams`, `callback`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `getHymn`(`hymnType`: @escaping @autoclosure () -> HymnType, `hymnNumber`: @escaping @autoclosure () -> String, `queryParams`: @escaping @autoclosure () -> [String: String]?, _ `callback`: @escaping @autoclosure () -> (Hymn?) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?, @escaping (Hymn?) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnType`), Mockingbird.resolve(`hymnNumber`), Mockingbird.resolve(`queryParams`), Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?, @escaping (Hymn?) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Hymns.HymnalApiService` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnalApiService.Protocol) -> HymnalApiServiceMock {
  return HymnalApiServiceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked HymnsRepositoryImpl

public final class HymnsRepositoryImplMock: Hymns.HymnsRepositoryImpl, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnsRepositoryImplMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`hymnalApiService`: Hymns.HymnalApiService, __file: StaticString = #file, __line: UInt = #line) -> HymnsRepositoryImplMock {
      let mock: HymnsRepositoryImplMock = HymnsRepositoryImplMock(hymnalApiService: `hymnalApiService`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void)

  public override func `getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hymnIdentifier`), Mockingbird.ArgumentMatcher(`callback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HymnIdentifier, @escaping (Hymn?) -> Void) -> Void {
      concreteImplementation(`hymnIdentifier`, `callback`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `getHymn`(`hymnIdentifier`: @escaping @autoclosure () -> HymnIdentifier, _ `callback`: @escaping @autoclosure () -> (Hymn?) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier, @escaping (Hymn?) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnIdentifier`), Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier, @escaping (Hymn?) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`hymnalApiService`: Hymns.HymnalApiService)

  public required override init(`hymnalApiService`: Hymns.HymnalApiService) {
    super.init(hymnalApiService: `hymnalApiService`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`hymnalApiService`: Hymns.HymnalApiService) ", arguments: [Mockingbird.ArgumentMatcher(`hymnalApiService`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnsRepositoryImpl` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnsRepositoryImpl.Type) -> HymnsRepositoryImplMock.InitializerProxy.Type {
  return HymnsRepositoryImplMock.InitializerProxy.self
}

// MARK: - Mocked HymnsRepository

public final class HymnsRepositoryMock: Hymns.HymnsRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnsRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void)

  public func `getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hymnIdentifier`), Mockingbird.ArgumentMatcher(`callback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HymnIdentifier, @escaping (Hymn?) -> Void) -> Void {
      concreteImplementation(`hymnIdentifier`, `callback`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `getHymn`(`hymnIdentifier`: @escaping @autoclosure () -> HymnIdentifier, _ `callback`: @escaping @autoclosure () -> (Hymn?) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier, @escaping (Hymn?) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnIdentifier`), Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier, @escaping (Hymn?) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `Hymns.HymnsRepository` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnsRepository.Protocol) -> HymnsRepositoryMock {
  return HymnsRepositoryMock(sourceLocation: SourceLocation(file, line))
}

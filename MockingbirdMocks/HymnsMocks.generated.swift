//
//  HymnsMocks.generated.swift
//  Hymns
//
//  Generated by Mockingbird v0.10.0.
//  DO NOT EDIT
//

// swiftlint:disable all

@testable import Hymns
@testable import Mockingbird
import Alamofire
import Foundation
import Resolver
import Swift
import SwiftUI

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked HymnLyricsViewModel

public final class HymnLyricsViewModelMock: Hymns.HymnLyricsViewModel, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnLyricsViewModelMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> HymnLyricsViewModelMock {
      let mock: HymnLyricsViewModelMock = HymnLyricsViewModelMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked lyrics

  override public var `lyrics`: [Verse]? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Verse]?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Verse]?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLyrics() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Verse]?, [Verse]?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Verse]?, [Verse]?>(mock: self, invocation: invocation)
  }

  public func setLyrics(_ newValue: @escaping @autoclosure () -> [Verse]?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Verse]?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lyrics.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([Verse]?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnLyricsViewModel` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnLyricsViewModel.Type) -> HymnLyricsViewModelMock.InitializerProxy.Type {
  return HymnLyricsViewModelMock.InitializerProxy.self
}

// MARK: - Mocked HymnalApiService

public final class HymnalApiServiceMock: Hymns.HymnalApiService, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnalApiServiceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`jsonDecoder`: JSONDecoder, __file: StaticString = #file, __line: UInt = #line) -> HymnalApiServiceMock {
      let mock: HymnalApiServiceMock = HymnalApiServiceMock(jsonDecoder: `jsonDecoder`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void)

  public override func `getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hymnType`), Mockingbird.ArgumentMatcher(`hymnNumber`), Mockingbird.ArgumentMatcher(`queryParams`), Mockingbird.ArgumentMatcher(`callback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HymnType, String, [String: String]?, @escaping (Hymn?) -> Void) -> Void {
      concreteImplementation(`hymnType`, `hymnNumber`, `queryParams`, `callback`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `getHymn`(`hymnType`: @escaping @autoclosure () -> HymnType, `hymnNumber`: @escaping @autoclosure () -> String, `queryParams`: @escaping @autoclosure () -> [String: String]?, _ `callback`: @escaping @autoclosure () -> (Hymn?) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?, @escaping (Hymn?) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnType`), Mockingbird.resolve(`hymnNumber`), Mockingbird.resolve(`queryParams`), Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnType`: HymnType, `hymnNumber`: String, `queryParams`: [String: String]?, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnType, String, [String: String]?, @escaping (Hymn?) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`jsonDecoder`: JSONDecoder)

  public required override init(`jsonDecoder`: JSONDecoder) {
    super.init(jsonDecoder: `jsonDecoder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`jsonDecoder`: JSONDecoder) ", arguments: [Mockingbird.ArgumentMatcher(`jsonDecoder`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnalApiService` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnalApiService.Type) -> HymnalApiServiceMock.InitializerProxy.Type {
  return HymnalApiServiceMock.InitializerProxy.self
}

// MARK: - Mocked HymnsRepository

public final class HymnsRepositoryMock: Hymns.HymnsRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.10.0", "module_name": "Hymns"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HymnsRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> HymnsRepositoryMock {
      let mock: HymnsRepositoryMock = HymnsRepositoryMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked hymns

  override public var `hymns`: [HymnIdentifier: Hymn] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hymns.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [HymnIdentifier: Hymn])()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hymns.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([HymnIdentifier: Hymn]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getHymns() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [HymnIdentifier: Hymn], [HymnIdentifier: Hymn]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hymns.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [HymnIdentifier: Hymn], [HymnIdentifier: Hymn]>(mock: self, invocation: invocation)
  }

  public func setHymns(_ newValue: @escaping @autoclosure () -> [HymnIdentifier: Hymn]) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([HymnIdentifier: Hymn]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hymns.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, ([HymnIdentifier: Hymn]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void)

  public override func `getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hymnIdentifier`), Mockingbird.ArgumentMatcher(`callback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HymnIdentifier, @escaping (Hymn?) -> Void) -> Void {
      concreteImplementation(`hymnIdentifier`, `callback`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `getHymn`(`hymnIdentifier`: @escaping @autoclosure () -> HymnIdentifier, _ `callback`: @escaping @autoclosure () -> (Hymn?) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier, @escaping (Hymn?) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hymnIdentifier`), Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getHymn`(`hymnIdentifier`: HymnIdentifier, _ `callback`: @escaping (Hymn?) -> Void) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HymnIdentifier, @escaping (Hymn?) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `Hymns.HymnsRepository` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: Hymns.HymnsRepository.Type) -> HymnsRepositoryMock.InitializerProxy.Type {
  return HymnsRepositoryMock.InitializerProxy.self
}
